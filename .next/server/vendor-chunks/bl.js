"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bl";
exports.ids = ["vendor-chunks/bl"];
exports.modules = {

/***/ "(rsc)/./node_modules/bl/BufferList.js":
/*!***************************************!*\
  !*** ./node_modules/bl/BufferList.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst symbol = Symbol.for('BufferList')\n\nfunction BufferList (buf) {\n  if (!(this instanceof BufferList)) {\n    return new BufferList(buf)\n  }\n\n  BufferList._init.call(this, buf)\n}\n\nBufferList._init = function _init (buf) {\n  Object.defineProperty(this, symbol, { value: true })\n\n  this._bufs = []\n  this.length = 0\n\n  if (buf) {\n    this.append(buf)\n  }\n}\n\nBufferList.prototype._new = function _new (buf) {\n  return new BufferList(buf)\n}\n\nBufferList.prototype._offset = function _offset (offset) {\n  if (offset === 0) {\n    return [0, 0]\n  }\n\n  let tot = 0\n\n  for (let i = 0; i < this._bufs.length; i++) {\n    const _t = tot + this._bufs[i].length\n    if (offset < _t || i === this._bufs.length - 1) {\n      return [i, offset - tot]\n    }\n    tot = _t\n  }\n}\n\nBufferList.prototype._reverseOffset = function (blOffset) {\n  const bufferId = blOffset[0]\n  let offset = blOffset[1]\n\n  for (let i = 0; i < bufferId; i++) {\n    offset += this._bufs[i].length\n  }\n\n  return offset\n}\n\nBufferList.prototype.getBuffers = function getBuffers () {\n  return this._bufs\n}\n\nBufferList.prototype.get = function get (index) {\n  if (index > this.length || index < 0) {\n    return undefined\n  }\n\n  const offset = this._offset(index)\n\n  return this._bufs[offset[0]][offset[1]]\n}\n\nBufferList.prototype.slice = function slice (start, end) {\n  if (typeof start === 'number' && start < 0) {\n    start += this.length\n  }\n\n  if (typeof end === 'number' && end < 0) {\n    end += this.length\n  }\n\n  return this.copy(null, 0, start, end)\n}\n\nBufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {\n  if (typeof srcStart !== 'number' || srcStart < 0) {\n    srcStart = 0\n  }\n\n  if (typeof srcEnd !== 'number' || srcEnd > this.length) {\n    srcEnd = this.length\n  }\n\n  if (srcStart >= this.length) {\n    return dst || Buffer.alloc(0)\n  }\n\n  if (srcEnd <= 0) {\n    return dst || Buffer.alloc(0)\n  }\n\n  const copy = !!dst\n  const off = this._offset(srcStart)\n  const len = srcEnd - srcStart\n  let bytes = len\n  let bufoff = (copy && dstStart) || 0\n  let start = off[1]\n\n  // copy/slice everything\n  if (srcStart === 0 && srcEnd === this.length) {\n    if (!copy) {\n      // slice, but full concat if multiple buffers\n      return this._bufs.length === 1\n        ? this._bufs[0]\n        : Buffer.concat(this._bufs, this.length)\n    }\n\n    // copy, need to copy individual buffers\n    for (let i = 0; i < this._bufs.length; i++) {\n      this._bufs[i].copy(dst, bufoff)\n      bufoff += this._bufs[i].length\n    }\n\n    return dst\n  }\n\n  // easy, cheap case where it's a subset of one of the buffers\n  if (bytes <= this._bufs[off[0]].length - start) {\n    return copy\n      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)\n      : this._bufs[off[0]].slice(start, start + bytes)\n  }\n\n  if (!copy) {\n    // a slice, we need something to copy in to\n    dst = Buffer.allocUnsafe(len)\n  }\n\n  for (let i = off[0]; i < this._bufs.length; i++) {\n    const l = this._bufs[i].length - start\n\n    if (bytes > l) {\n      this._bufs[i].copy(dst, bufoff, start)\n      bufoff += l\n    } else {\n      this._bufs[i].copy(dst, bufoff, start, start + bytes)\n      bufoff += l\n      break\n    }\n\n    bytes -= l\n\n    if (start) {\n      start = 0\n    }\n  }\n\n  // safeguard so that we don't return uninitialized memory\n  if (dst.length > bufoff) return dst.slice(0, bufoff)\n\n  return dst\n}\n\nBufferList.prototype.shallowSlice = function shallowSlice (start, end) {\n  start = start || 0\n  end = typeof end !== 'number' ? this.length : end\n\n  if (start < 0) {\n    start += this.length\n  }\n\n  if (end < 0) {\n    end += this.length\n  }\n\n  if (start === end) {\n    return this._new()\n  }\n\n  const startOffset = this._offset(start)\n  const endOffset = this._offset(end)\n  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)\n\n  if (endOffset[1] === 0) {\n    buffers.pop()\n  } else {\n    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1])\n  }\n\n  if (startOffset[1] !== 0) {\n    buffers[0] = buffers[0].slice(startOffset[1])\n  }\n\n  return this._new(buffers)\n}\n\nBufferList.prototype.toString = function toString (encoding, start, end) {\n  return this.slice(start, end).toString(encoding)\n}\n\nBufferList.prototype.consume = function consume (bytes) {\n  // first, normalize the argument, in accordance with how Buffer does it\n  bytes = Math.trunc(bytes)\n  // do nothing if not a positive number\n  if (Number.isNaN(bytes) || bytes <= 0) return this\n\n  while (this._bufs.length) {\n    if (bytes >= this._bufs[0].length) {\n      bytes -= this._bufs[0].length\n      this.length -= this._bufs[0].length\n      this._bufs.shift()\n    } else {\n      this._bufs[0] = this._bufs[0].slice(bytes)\n      this.length -= bytes\n      break\n    }\n  }\n\n  return this\n}\n\nBufferList.prototype.duplicate = function duplicate () {\n  const copy = this._new()\n\n  for (let i = 0; i < this._bufs.length; i++) {\n    copy.append(this._bufs[i])\n  }\n\n  return copy\n}\n\nBufferList.prototype.append = function append (buf) {\n  return this._attach(buf, BufferList.prototype._appendBuffer)\n}\n\nBufferList.prototype.prepend = function prepend (buf) {\n  return this._attach(buf, BufferList.prototype._prependBuffer, true)\n}\n\nBufferList.prototype._attach = function _attach (buf, attacher, prepend) {\n  if (buf == null) {\n    return this\n  }\n\n  if (buf.buffer) {\n    // append/prepend a view of the underlying ArrayBuffer\n    attacher.call(this, Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength))\n  } else if (Array.isArray(buf)) {\n    const [starting, modifier] = prepend ? [buf.length - 1, -1] : [0, 1]\n\n    for (let i = starting; i >= 0 && i < buf.length; i += modifier) {\n      this._attach(buf[i], attacher, prepend)\n    }\n  } else if (this._isBufferList(buf)) {\n    // unwrap argument into individual BufferLists\n    const [starting, modifier] = prepend ? [buf._bufs.length - 1, -1] : [0, 1]\n\n    for (let i = starting; i >= 0 && i < buf._bufs.length; i += modifier) {\n      this._attach(buf._bufs[i], attacher, prepend)\n    }\n  } else {\n    // coerce number arguments to strings, since Buffer(number) does\n    // uninitialized memory allocation\n    if (typeof buf === 'number') {\n      buf = buf.toString()\n    }\n\n    attacher.call(this, Buffer.from(buf))\n  }\n\n  return this\n}\n\nBufferList.prototype._appendBuffer = function appendBuffer (buf) {\n  this._bufs.push(buf)\n  this.length += buf.length\n}\n\nBufferList.prototype._prependBuffer = function prependBuffer (buf) {\n  this._bufs.unshift(buf)\n  this.length += buf.length\n}\n\nBufferList.prototype.indexOf = function (search, offset, encoding) {\n  if (encoding === undefined && typeof offset === 'string') {\n    encoding = offset\n    offset = undefined\n  }\n\n  if (typeof search === 'function' || Array.isArray(search)) {\n    throw new TypeError('The \"value\" argument must be one of type string, Buffer, BufferList, or Uint8Array.')\n  } else if (typeof search === 'number') {\n    search = Buffer.from([search])\n  } else if (typeof search === 'string') {\n    search = Buffer.from(search, encoding)\n  } else if (this._isBufferList(search)) {\n    search = search.slice()\n  } else if (Array.isArray(search.buffer)) {\n    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength)\n  } else if (!Buffer.isBuffer(search)) {\n    search = Buffer.from(search)\n  }\n\n  offset = Number(offset || 0)\n\n  if (isNaN(offset)) {\n    offset = 0\n  }\n\n  if (offset < 0) {\n    offset = this.length + offset\n  }\n\n  if (offset < 0) {\n    offset = 0\n  }\n\n  if (search.length === 0) {\n    return offset > this.length ? this.length : offset\n  }\n\n  const blOffset = this._offset(offset)\n  let blIndex = blOffset[0] // index of which internal buffer we're working on\n  let buffOffset = blOffset[1] // offset of the internal buffer we're working on\n\n  // scan over each buffer\n  for (; blIndex < this._bufs.length; blIndex++) {\n    const buff = this._bufs[blIndex]\n\n    while (buffOffset < buff.length) {\n      const availableWindow = buff.length - buffOffset\n\n      if (availableWindow >= search.length) {\n        const nativeSearchResult = buff.indexOf(search, buffOffset)\n\n        if (nativeSearchResult !== -1) {\n          return this._reverseOffset([blIndex, nativeSearchResult])\n        }\n\n        buffOffset = buff.length - search.length + 1 // end of native search window\n      } else {\n        const revOffset = this._reverseOffset([blIndex, buffOffset])\n\n        if (this._match(revOffset, search)) {\n          return revOffset\n        }\n\n        buffOffset++\n      }\n    }\n\n    buffOffset = 0\n  }\n\n  return -1\n}\n\nBufferList.prototype._match = function (offset, search) {\n  if (this.length - offset < search.length) {\n    return false\n  }\n\n  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {\n    if (this.get(offset + searchOffset) !== search[searchOffset]) {\n      return false\n    }\n  }\n  return true\n}\n\n;(function () {\n  const methods = {\n    readDoubleBE: 8,\n    readDoubleLE: 8,\n    readFloatBE: 4,\n    readFloatLE: 4,\n    readBigInt64BE: 8,\n    readBigInt64LE: 8,\n    readBigUInt64BE: 8,\n    readBigUInt64LE: 8,\n    readInt32BE: 4,\n    readInt32LE: 4,\n    readUInt32BE: 4,\n    readUInt32LE: 4,\n    readInt16BE: 2,\n    readInt16LE: 2,\n    readUInt16BE: 2,\n    readUInt16LE: 2,\n    readInt8: 1,\n    readUInt8: 1,\n    readIntBE: null,\n    readIntLE: null,\n    readUIntBE: null,\n    readUIntLE: null\n  }\n\n  for (const m in methods) {\n    (function (m) {\n      if (methods[m] === null) {\n        BufferList.prototype[m] = function (offset, byteLength) {\n          return this.slice(offset, offset + byteLength)[m](0, byteLength)\n        }\n      } else {\n        BufferList.prototype[m] = function (offset = 0) {\n          return this.slice(offset, offset + methods[m])[m](0)\n        }\n      }\n    }(m))\n  }\n}())\n\n// Used internally by the class and also as an indicator of this object being\n// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser\n// environment because there could be multiple different copies of the\n// BufferList class and some `BufferList`s might be `BufferList`s.\nBufferList.prototype._isBufferList = function _isBufferList (b) {\n  return b instanceof BufferList || BufferList.isBufferList(b)\n}\n\nBufferList.isBufferList = function isBufferList (b) {\n  return b != null && b[symbol]\n}\n\nmodule.exports = BufferList\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmwvQnVmZmVyTGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsYUFBYTs7QUFFckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHVCQUF1QjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDZCQUE2QjtBQUN0Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtdHlwZXNjcmlwdC1yZWR1eC1zYW1wbGUvLi9ub2RlX21vZHVsZXMvYmwvQnVmZmVyTGlzdC5qcz80ZWYyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ0J1ZmZlckxpc3QnKVxuXG5mdW5jdGlvbiBCdWZmZXJMaXN0IChidWYpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJMaXN0KGJ1ZilcbiAgfVxuXG4gIEJ1ZmZlckxpc3QuX2luaXQuY2FsbCh0aGlzLCBidWYpXG59XG5cbkJ1ZmZlckxpc3QuX2luaXQgPSBmdW5jdGlvbiBfaW5pdCAoYnVmKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBzeW1ib2wsIHsgdmFsdWU6IHRydWUgfSlcblxuICB0aGlzLl9idWZzID0gW11cbiAgdGhpcy5sZW5ndGggPSAwXG5cbiAgaWYgKGJ1Zikge1xuICAgIHRoaXMuYXBwZW5kKGJ1ZilcbiAgfVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fbmV3ID0gZnVuY3Rpb24gX25ldyAoYnVmKSB7XG4gIHJldHVybiBuZXcgQnVmZmVyTGlzdChidWYpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9vZmZzZXQgPSBmdW5jdGlvbiBfb2Zmc2V0IChvZmZzZXQpIHtcbiAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgIHJldHVybiBbMCwgMF1cbiAgfVxuXG4gIGxldCB0b3QgPSAwXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgX3QgPSB0b3QgKyB0aGlzLl9idWZzW2ldLmxlbmd0aFxuICAgIGlmIChvZmZzZXQgPCBfdCB8fCBpID09PSB0aGlzLl9idWZzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBbaSwgb2Zmc2V0IC0gdG90XVxuICAgIH1cbiAgICB0b3QgPSBfdFxuICB9XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9yZXZlcnNlT2Zmc2V0ID0gZnVuY3Rpb24gKGJsT2Zmc2V0KSB7XG4gIGNvbnN0IGJ1ZmZlcklkID0gYmxPZmZzZXRbMF1cbiAgbGV0IG9mZnNldCA9IGJsT2Zmc2V0WzFdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJJZDsgaSsrKSB7XG4gICAgb2Zmc2V0ICs9IHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmdldEJ1ZmZlcnMgPSBmdW5jdGlvbiBnZXRCdWZmZXJzICgpIHtcbiAgcmV0dXJuIHRoaXMuX2J1ZnNcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCkge1xuICBpZiAoaW5kZXggPiB0aGlzLmxlbmd0aCB8fCBpbmRleCA8IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBvZmZzZXQgPSB0aGlzLl9vZmZzZXQoaW5kZXgpXG5cbiAgcmV0dXJuIHRoaXMuX2J1ZnNbb2Zmc2V0WzBdXVtvZmZzZXRbMV1dXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiYgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJyAmJiBlbmQgPCAwKSB7XG4gICAgZW5kICs9IHRoaXMubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIDAsIHN0YXJ0LCBlbmQpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkc3QsIGRzdFN0YXJ0LCBzcmNTdGFydCwgc3JjRW5kKSB7XG4gIGlmICh0eXBlb2Ygc3JjU3RhcnQgIT09ICdudW1iZXInIHx8IHNyY1N0YXJ0IDwgMCkge1xuICAgIHNyY1N0YXJ0ID0gMFxuICB9XG5cbiAgaWYgKHR5cGVvZiBzcmNFbmQgIT09ICdudW1iZXInIHx8IHNyY0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3JjRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzcmNTdGFydCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiBkc3QgfHwgQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBpZiAoc3JjRW5kIDw9IDApIHtcbiAgICByZXR1cm4gZHN0IHx8IEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgY29uc3QgY29weSA9ICEhZHN0XG4gIGNvbnN0IG9mZiA9IHRoaXMuX29mZnNldChzcmNTdGFydClcbiAgY29uc3QgbGVuID0gc3JjRW5kIC0gc3JjU3RhcnRcbiAgbGV0IGJ5dGVzID0gbGVuXG4gIGxldCBidWZvZmYgPSAoY29weSAmJiBkc3RTdGFydCkgfHwgMFxuICBsZXQgc3RhcnQgPSBvZmZbMV1cblxuICAvLyBjb3B5L3NsaWNlIGV2ZXJ5dGhpbmdcbiAgaWYgKHNyY1N0YXJ0ID09PSAwICYmIHNyY0VuZCA9PT0gdGhpcy5sZW5ndGgpIHtcbiAgICBpZiAoIWNvcHkpIHtcbiAgICAgIC8vIHNsaWNlLCBidXQgZnVsbCBjb25jYXQgaWYgbXVsdGlwbGUgYnVmZmVyc1xuICAgICAgcmV0dXJuIHRoaXMuX2J1ZnMubGVuZ3RoID09PSAxXG4gICAgICAgID8gdGhpcy5fYnVmc1swXVxuICAgICAgICA6IEJ1ZmZlci5jb25jYXQodGhpcy5fYnVmcywgdGhpcy5sZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gY29weSwgbmVlZCB0byBjb3B5IGluZGl2aWR1YWwgYnVmZmVyc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmKVxuICAgICAgYnVmb2ZmICs9IHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIGRzdFxuICB9XG5cbiAgLy8gZWFzeSwgY2hlYXAgY2FzZSB3aGVyZSBpdCdzIGEgc3Vic2V0IG9mIG9uZSBvZiB0aGUgYnVmZmVyc1xuICBpZiAoYnl0ZXMgPD0gdGhpcy5fYnVmc1tvZmZbMF1dLmxlbmd0aCAtIHN0YXJ0KSB7XG4gICAgcmV0dXJuIGNvcHlcbiAgICAgID8gdGhpcy5fYnVmc1tvZmZbMF1dLmNvcHkoZHN0LCBkc3RTdGFydCwgc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gICAgICA6IHRoaXMuX2J1ZnNbb2ZmWzBdXS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgfVxuXG4gIGlmICghY29weSkge1xuICAgIC8vIGEgc2xpY2UsIHdlIG5lZWQgc29tZXRoaW5nIHRvIGNvcHkgaW4gdG9cbiAgICBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IG9mZlswXTsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsID0gdGhpcy5fYnVmc1tpXS5sZW5ndGggLSBzdGFydFxuXG4gICAgaWYgKGJ5dGVzID4gbCkge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmLCBzdGFydClcbiAgICAgIGJ1Zm9mZiArPSBsXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1ZnNbaV0uY29weShkc3QsIGJ1Zm9mZiwgc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gICAgICBidWZvZmYgKz0gbFxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBieXRlcyAtPSBsXG5cbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gMFxuICAgIH1cbiAgfVxuXG4gIC8vIHNhZmVndWFyZCBzbyB0aGF0IHdlIGRvbid0IHJldHVybiB1bmluaXRpYWxpemVkIG1lbW9yeVxuICBpZiAoZHN0Lmxlbmd0aCA+IGJ1Zm9mZikgcmV0dXJuIGRzdC5zbGljZSgwLCBidWZvZmYpXG5cbiAgcmV0dXJuIGRzdFxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zaGFsbG93U2xpY2UgPSBmdW5jdGlvbiBzaGFsbG93U2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwXG4gIGVuZCA9IHR5cGVvZiBlbmQgIT09ICdudW1iZXInID8gdGhpcy5sZW5ndGggOiBlbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgIHJldHVybiB0aGlzLl9uZXcoKVxuICB9XG5cbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLl9vZmZzZXQoc3RhcnQpXG4gIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMuX29mZnNldChlbmQpXG4gIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLl9idWZzLnNsaWNlKHN0YXJ0T2Zmc2V0WzBdLCBlbmRPZmZzZXRbMF0gKyAxKVxuXG4gIGlmIChlbmRPZmZzZXRbMV0gPT09IDApIHtcbiAgICBidWZmZXJzLnBvcCgpXG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyc1tidWZmZXJzLmxlbmd0aCAtIDFdID0gYnVmZmVyc1tidWZmZXJzLmxlbmd0aCAtIDFdLnNsaWNlKDAsIGVuZE9mZnNldFsxXSlcbiAgfVxuXG4gIGlmIChzdGFydE9mZnNldFsxXSAhPT0gMCkge1xuICAgIGJ1ZmZlcnNbMF0gPSBidWZmZXJzWzBdLnNsaWNlKHN0YXJ0T2Zmc2V0WzFdKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX25ldyhidWZmZXJzKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKS50b1N0cmluZyhlbmNvZGluZylcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIGNvbnN1bWUgKGJ5dGVzKSB7XG4gIC8vIGZpcnN0LCBub3JtYWxpemUgdGhlIGFyZ3VtZW50LCBpbiBhY2NvcmRhbmNlIHdpdGggaG93IEJ1ZmZlciBkb2VzIGl0XG4gIGJ5dGVzID0gTWF0aC50cnVuYyhieXRlcylcbiAgLy8gZG8gbm90aGluZyBpZiBub3QgYSBwb3NpdGl2ZSBudW1iZXJcbiAgaWYgKE51bWJlci5pc05hTihieXRlcykgfHwgYnl0ZXMgPD0gMCkgcmV0dXJuIHRoaXNcblxuICB3aGlsZSAodGhpcy5fYnVmcy5sZW5ndGgpIHtcbiAgICBpZiAoYnl0ZXMgPj0gdGhpcy5fYnVmc1swXS5sZW5ndGgpIHtcbiAgICAgIGJ5dGVzIC09IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoXG4gICAgICB0aGlzLmxlbmd0aCAtPSB0aGlzLl9idWZzWzBdLmxlbmd0aFxuICAgICAgdGhpcy5fYnVmcy5zaGlmdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1ZnNbMF0gPSB0aGlzLl9idWZzWzBdLnNsaWNlKGJ5dGVzKVxuICAgICAgdGhpcy5sZW5ndGggLT0gYnl0ZXNcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZHVwbGljYXRlID0gZnVuY3Rpb24gZHVwbGljYXRlICgpIHtcbiAgY29uc3QgY29weSA9IHRoaXMuX25ldygpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29weS5hcHBlbmQodGhpcy5fYnVmc1tpXSlcbiAgfVxuXG4gIHJldHVybiBjb3B5XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAoYnVmKSB7XG4gIHJldHVybiB0aGlzLl9hdHRhY2goYnVmLCBCdWZmZXJMaXN0LnByb3RvdHlwZS5fYXBwZW5kQnVmZmVyKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCAoYnVmKSB7XG4gIHJldHVybiB0aGlzLl9hdHRhY2goYnVmLCBCdWZmZXJMaXN0LnByb3RvdHlwZS5fcHJlcGVuZEJ1ZmZlciwgdHJ1ZSlcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX2F0dGFjaCA9IGZ1bmN0aW9uIF9hdHRhY2ggKGJ1ZiwgYXR0YWNoZXIsIHByZXBlbmQpIHtcbiAgaWYgKGJ1ZiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlmIChidWYuYnVmZmVyKSB7XG4gICAgLy8gYXBwZW5kL3ByZXBlbmQgYSB2aWV3IG9mIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyXG4gICAgYXR0YWNoZXIuY2FsbCh0aGlzLCBCdWZmZXIuZnJvbShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYnVmKSkge1xuICAgIGNvbnN0IFtzdGFydGluZywgbW9kaWZpZXJdID0gcHJlcGVuZCA/IFtidWYubGVuZ3RoIC0gMSwgLTFdIDogWzAsIDFdXG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnRpbmc7IGkgPj0gMCAmJiBpIDwgYnVmLmxlbmd0aDsgaSArPSBtb2RpZmllcikge1xuICAgICAgdGhpcy5fYXR0YWNoKGJ1ZltpXSwgYXR0YWNoZXIsIHByZXBlbmQpXG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuX2lzQnVmZmVyTGlzdChidWYpKSB7XG4gICAgLy8gdW53cmFwIGFyZ3VtZW50IGludG8gaW5kaXZpZHVhbCBCdWZmZXJMaXN0c1xuICAgIGNvbnN0IFtzdGFydGluZywgbW9kaWZpZXJdID0gcHJlcGVuZCA/IFtidWYuX2J1ZnMubGVuZ3RoIC0gMSwgLTFdIDogWzAsIDFdXG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnRpbmc7IGkgPj0gMCAmJiBpIDwgYnVmLl9idWZzLmxlbmd0aDsgaSArPSBtb2RpZmllcikge1xuICAgICAgdGhpcy5fYXR0YWNoKGJ1Zi5fYnVmc1tpXSwgYXR0YWNoZXIsIHByZXBlbmQpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGNvZXJjZSBudW1iZXIgYXJndW1lbnRzIHRvIHN0cmluZ3MsIHNpbmNlIEJ1ZmZlcihudW1iZXIpIGRvZXNcbiAgICAvLyB1bmluaXRpYWxpemVkIG1lbW9yeSBhbGxvY2F0aW9uXG4gICAgaWYgKHR5cGVvZiBidWYgPT09ICdudW1iZXInKSB7XG4gICAgICBidWYgPSBidWYudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIGF0dGFjaGVyLmNhbGwodGhpcywgQnVmZmVyLmZyb20oYnVmKSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9hcHBlbmRCdWZmZXIgPSBmdW5jdGlvbiBhcHBlbmRCdWZmZXIgKGJ1Zikge1xuICB0aGlzLl9idWZzLnB1c2goYnVmKVxuICB0aGlzLmxlbmd0aCArPSBidWYubGVuZ3RoXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9wcmVwZW5kQnVmZmVyID0gZnVuY3Rpb24gcHJlcGVuZEJ1ZmZlciAoYnVmKSB7XG4gIHRoaXMuX2J1ZnMudW5zaGlmdChidWYpXG4gIHRoaXMubGVuZ3RoICs9IGJ1Zi5sZW5ndGhcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2gsIG9mZnNldCwgZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShzZWFyY2gpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBCdWZmZXJMaXN0LCBvciBVaW50OEFycmF5LicpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ251bWJlcicpIHtcbiAgICBzZWFyY2ggPSBCdWZmZXIuZnJvbShbc2VhcmNoXSlcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VhcmNoID09PSAnc3RyaW5nJykge1xuICAgIHNlYXJjaCA9IEJ1ZmZlci5mcm9tKHNlYXJjaCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodGhpcy5faXNCdWZmZXJMaXN0KHNlYXJjaCkpIHtcbiAgICBzZWFyY2ggPSBzZWFyY2guc2xpY2UoKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VhcmNoLmJ1ZmZlcikpIHtcbiAgICBzZWFyY2ggPSBCdWZmZXIuZnJvbShzZWFyY2guYnVmZmVyLCBzZWFyY2guYnl0ZU9mZnNldCwgc2VhcmNoLmJ5dGVMZW5ndGgpXG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzZWFyY2gpKSB7XG4gICAgc2VhcmNoID0gQnVmZmVyLmZyb20oc2VhcmNoKVxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCB8fCAwKVxuXG4gIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gMFxuICB9XG5cbiAgaWYgKG9mZnNldCA8IDApIHtcbiAgICBvZmZzZXQgPSB0aGlzLmxlbmd0aCArIG9mZnNldFxuICB9XG5cbiAgaWYgKG9mZnNldCA8IDApIHtcbiAgICBvZmZzZXQgPSAwXG4gIH1cblxuICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvZmZzZXQgPiB0aGlzLmxlbmd0aCA/IHRoaXMubGVuZ3RoIDogb2Zmc2V0XG4gIH1cblxuICBjb25zdCBibE9mZnNldCA9IHRoaXMuX29mZnNldChvZmZzZXQpXG4gIGxldCBibEluZGV4ID0gYmxPZmZzZXRbMF0gLy8gaW5kZXggb2Ygd2hpY2ggaW50ZXJuYWwgYnVmZmVyIHdlJ3JlIHdvcmtpbmcgb25cbiAgbGV0IGJ1ZmZPZmZzZXQgPSBibE9mZnNldFsxXSAvLyBvZmZzZXQgb2YgdGhlIGludGVybmFsIGJ1ZmZlciB3ZSdyZSB3b3JraW5nIG9uXG5cbiAgLy8gc2NhbiBvdmVyIGVhY2ggYnVmZmVyXG4gIGZvciAoOyBibEluZGV4IDwgdGhpcy5fYnVmcy5sZW5ndGg7IGJsSW5kZXgrKykge1xuICAgIGNvbnN0IGJ1ZmYgPSB0aGlzLl9idWZzW2JsSW5kZXhdXG5cbiAgICB3aGlsZSAoYnVmZk9mZnNldCA8IGJ1ZmYubGVuZ3RoKSB7XG4gICAgICBjb25zdCBhdmFpbGFibGVXaW5kb3cgPSBidWZmLmxlbmd0aCAtIGJ1ZmZPZmZzZXRcblxuICAgICAgaWYgKGF2YWlsYWJsZVdpbmRvdyA+PSBzZWFyY2gubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZVNlYXJjaFJlc3VsdCA9IGJ1ZmYuaW5kZXhPZihzZWFyY2gsIGJ1ZmZPZmZzZXQpXG5cbiAgICAgICAgaWYgKG5hdGl2ZVNlYXJjaFJlc3VsdCAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZU9mZnNldChbYmxJbmRleCwgbmF0aXZlU2VhcmNoUmVzdWx0XSlcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZPZmZzZXQgPSBidWZmLmxlbmd0aCAtIHNlYXJjaC5sZW5ndGggKyAxIC8vIGVuZCBvZiBuYXRpdmUgc2VhcmNoIHdpbmRvd1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmV2T2Zmc2V0ID0gdGhpcy5fcmV2ZXJzZU9mZnNldChbYmxJbmRleCwgYnVmZk9mZnNldF0pXG5cbiAgICAgICAgaWYgKHRoaXMuX21hdGNoKHJldk9mZnNldCwgc2VhcmNoKSkge1xuICAgICAgICAgIHJldHVybiByZXZPZmZzZXRcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZPZmZzZXQrK1xuICAgICAgfVxuICAgIH1cblxuICAgIGJ1ZmZPZmZzZXQgPSAwXG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX21hdGNoID0gZnVuY3Rpb24gKG9mZnNldCwgc2VhcmNoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCAtIG9mZnNldCA8IHNlYXJjaC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAobGV0IHNlYXJjaE9mZnNldCA9IDA7IHNlYXJjaE9mZnNldCA8IHNlYXJjaC5sZW5ndGg7IHNlYXJjaE9mZnNldCsrKSB7XG4gICAgaWYgKHRoaXMuZ2V0KG9mZnNldCArIHNlYXJjaE9mZnNldCkgIT09IHNlYXJjaFtzZWFyY2hPZmZzZXRdKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuOyhmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgcmVhZERvdWJsZUJFOiA4LFxuICAgIHJlYWREb3VibGVMRTogOCxcbiAgICByZWFkRmxvYXRCRTogNCxcbiAgICByZWFkRmxvYXRMRTogNCxcbiAgICByZWFkQmlnSW50NjRCRTogOCxcbiAgICByZWFkQmlnSW50NjRMRTogOCxcbiAgICByZWFkQmlnVUludDY0QkU6IDgsXG4gICAgcmVhZEJpZ1VJbnQ2NExFOiA4LFxuICAgIHJlYWRJbnQzMkJFOiA0LFxuICAgIHJlYWRJbnQzMkxFOiA0LFxuICAgIHJlYWRVSW50MzJCRTogNCxcbiAgICByZWFkVUludDMyTEU6IDQsXG4gICAgcmVhZEludDE2QkU6IDIsXG4gICAgcmVhZEludDE2TEU6IDIsXG4gICAgcmVhZFVJbnQxNkJFOiAyLFxuICAgIHJlYWRVSW50MTZMRTogMixcbiAgICByZWFkSW50ODogMSxcbiAgICByZWFkVUludDg6IDEsXG4gICAgcmVhZEludEJFOiBudWxsLFxuICAgIHJlYWRJbnRMRTogbnVsbCxcbiAgICByZWFkVUludEJFOiBudWxsLFxuICAgIHJlYWRVSW50TEU6IG51bGxcbiAgfVxuXG4gIGZvciAoY29uc3QgbSBpbiBtZXRob2RzKSB7XG4gICAgKGZ1bmN0aW9uIChtKSB7XG4gICAgICBpZiAobWV0aG9kc1ttXSA9PT0gbnVsbCkge1xuICAgICAgICBCdWZmZXJMaXN0LnByb3RvdHlwZVttXSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJ5dGVMZW5ndGgpW21dKDAsIGJ5dGVMZW5ndGgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEJ1ZmZlckxpc3QucHJvdG90eXBlW21dID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zbGljZShvZmZzZXQsIG9mZnNldCArIG1ldGhvZHNbbV0pW21dKDApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KG0pKVxuICB9XG59KCkpXG5cbi8vIFVzZWQgaW50ZXJuYWxseSBieSB0aGUgY2xhc3MgYW5kIGFsc28gYXMgYW4gaW5kaWNhdG9yIG9mIHRoaXMgb2JqZWN0IGJlaW5nXG4vLyBhIGBCdWZmZXJMaXN0YC4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlckxpc3RgIGluIGEgYnJvd3NlclxuLy8gZW52aXJvbm1lbnQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnQgY29waWVzIG9mIHRoZVxuLy8gQnVmZmVyTGlzdCBjbGFzcyBhbmQgc29tZSBgQnVmZmVyTGlzdGBzIG1pZ2h0IGJlIGBCdWZmZXJMaXN0YHMuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5faXNCdWZmZXJMaXN0ID0gZnVuY3Rpb24gX2lzQnVmZmVyTGlzdCAoYikge1xuICByZXR1cm4gYiBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QgfHwgQnVmZmVyTGlzdC5pc0J1ZmZlckxpc3QoYilcbn1cblxuQnVmZmVyTGlzdC5pc0J1ZmZlckxpc3QgPSBmdW5jdGlvbiBpc0J1ZmZlckxpc3QgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiW3N5bWJvbF1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJMaXN0XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bl/BufferList.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bl/bl.js":
/*!*******************************!*\
  !*** ./node_modules/bl/bl.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst DuplexStream = (__webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/lib/ours/index.js\").Duplex)\nconst inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\")\nconst BufferList = __webpack_require__(/*! ./BufferList */ \"(rsc)/./node_modules/bl/BufferList.js\")\n\nfunction BufferListStream (callback) {\n  if (!(this instanceof BufferListStream)) {\n    return new BufferListStream(callback)\n  }\n\n  if (typeof callback === 'function') {\n    this._callback = callback\n\n    const piper = function piper (err) {\n      if (this._callback) {\n        this._callback(err)\n        this._callback = null\n      }\n    }.bind(this)\n\n    this.on('pipe', function onPipe (src) {\n      src.on('error', piper)\n    })\n    this.on('unpipe', function onUnpipe (src) {\n      src.removeListener('error', piper)\n    })\n\n    callback = null\n  }\n\n  BufferList._init.call(this, callback)\n  DuplexStream.call(this)\n}\n\ninherits(BufferListStream, DuplexStream)\nObject.assign(BufferListStream.prototype, BufferList.prototype)\n\nBufferListStream.prototype._new = function _new (callback) {\n  return new BufferListStream(callback)\n}\n\nBufferListStream.prototype._write = function _write (buf, encoding, callback) {\n  this._appendBuffer(buf)\n\n  if (typeof callback === 'function') {\n    callback()\n  }\n}\n\nBufferListStream.prototype._read = function _read (size) {\n  if (!this.length) {\n    return this.push(null)\n  }\n\n  size = Math.min(size, this.length)\n  this.push(this.slice(0, size))\n  this.consume(size)\n}\n\nBufferListStream.prototype.end = function end (chunk) {\n  DuplexStream.prototype.end.call(this, chunk)\n\n  if (this._callback) {\n    this._callback(null, this.slice())\n    this._callback = null\n  }\n}\n\nBufferListStream.prototype._destroy = function _destroy (err, cb) {\n  this._bufs.length = 0\n  this.length = 0\n  cb(err)\n}\n\nBufferListStream.prototype._isBufferList = function _isBufferList (b) {\n  return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b)\n}\n\nBufferListStream.isBufferList = BufferList.isBufferList\n\nmodule.exports = BufferListStream\nmodule.exports.BufferListStream = BufferListStream\nmodule.exports.BufferList = BufferList\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmwvYmwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVoscUJBQXFCLDZHQUFpQztBQUN0RCxpQkFBaUIsbUJBQU8sQ0FBQywyREFBVTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQywyREFBYzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy10eXBlc2NyaXB0LXJlZHV4LXNhbXBsZS8uL25vZGVfbW9kdWxlcy9ibC9ibC5qcz8yMjRkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBEdXBsZXhTdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5EdXBsZXhcbmNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuY29uc3QgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vQnVmZmVyTGlzdCcpXG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3RTdHJlYW0gKGNhbGxiYWNrKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXJMaXN0U3RyZWFtKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyTGlzdFN0cmVhbShjYWxsYmFjaylcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrXG5cbiAgICBjb25zdCBwaXBlciA9IGZ1bmN0aW9uIHBpcGVyIChlcnIpIHtcbiAgICAgIGlmICh0aGlzLl9jYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jYWxsYmFjayhlcnIpXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbFxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5vbigncGlwZScsIGZ1bmN0aW9uIG9uUGlwZSAoc3JjKSB7XG4gICAgICBzcmMub24oJ2Vycm9yJywgcGlwZXIpXG4gICAgfSlcbiAgICB0aGlzLm9uKCd1bnBpcGUnLCBmdW5jdGlvbiBvblVucGlwZSAoc3JjKSB7XG4gICAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgcGlwZXIpXG4gICAgfSlcblxuICAgIGNhbGxiYWNrID0gbnVsbFxuICB9XG5cbiAgQnVmZmVyTGlzdC5faW5pdC5jYWxsKHRoaXMsIGNhbGxiYWNrKVxuICBEdXBsZXhTdHJlYW0uY2FsbCh0aGlzKVxufVxuXG5pbmhlcml0cyhCdWZmZXJMaXN0U3RyZWFtLCBEdXBsZXhTdHJlYW0pXG5PYmplY3QuYXNzaWduKEJ1ZmZlckxpc3RTdHJlYW0ucHJvdG90eXBlLCBCdWZmZXJMaXN0LnByb3RvdHlwZSlcblxuQnVmZmVyTGlzdFN0cmVhbS5wcm90b3R5cGUuX25ldyA9IGZ1bmN0aW9uIF9uZXcgKGNhbGxiYWNrKSB7XG4gIHJldHVybiBuZXcgQnVmZmVyTGlzdFN0cmVhbShjYWxsYmFjaylcbn1cblxuQnVmZmVyTGlzdFN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlIChidWYsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICB0aGlzLl9hcHBlbmRCdWZmZXIoYnVmKVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjaygpXG4gIH1cbn1cblxuQnVmZmVyTGlzdFN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiBfcmVhZCAoc2l6ZSkge1xuICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaChudWxsKVxuICB9XG5cbiAgc2l6ZSA9IE1hdGgubWluKHNpemUsIHRoaXMubGVuZ3RoKVxuICB0aGlzLnB1c2godGhpcy5zbGljZSgwLCBzaXplKSlcbiAgdGhpcy5jb25zdW1lKHNpemUpXG59XG5cbkJ1ZmZlckxpc3RTdHJlYW0ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZCAoY2h1bmspIHtcbiAgRHVwbGV4U3RyZWFtLnByb3RvdHlwZS5lbmQuY2FsbCh0aGlzLCBjaHVuaylcblxuICBpZiAodGhpcy5fY2FsbGJhY2spIHtcbiAgICB0aGlzLl9jYWxsYmFjayhudWxsLCB0aGlzLnNsaWNlKCkpXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsXG4gIH1cbn1cblxuQnVmZmVyTGlzdFN0cmVhbS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiBfZGVzdHJveSAoZXJyLCBjYikge1xuICB0aGlzLl9idWZzLmxlbmd0aCA9IDBcbiAgdGhpcy5sZW5ndGggPSAwXG4gIGNiKGVycilcbn1cblxuQnVmZmVyTGlzdFN0cmVhbS5wcm90b3R5cGUuX2lzQnVmZmVyTGlzdCA9IGZ1bmN0aW9uIF9pc0J1ZmZlckxpc3QgKGIpIHtcbiAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCdWZmZXJMaXN0U3RyZWFtIHx8IGIgaW5zdGFuY2VvZiBCdWZmZXJMaXN0IHx8IEJ1ZmZlckxpc3RTdHJlYW0uaXNCdWZmZXJMaXN0KGIpXG59XG5cbkJ1ZmZlckxpc3RTdHJlYW0uaXNCdWZmZXJMaXN0ID0gQnVmZmVyTGlzdC5pc0J1ZmZlckxpc3RcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJMaXN0U3RyZWFtXG5tb2R1bGUuZXhwb3J0cy5CdWZmZXJMaXN0U3RyZWFtID0gQnVmZmVyTGlzdFN0cmVhbVxubW9kdWxlLmV4cG9ydHMuQnVmZmVyTGlzdCA9IEJ1ZmZlckxpc3RcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bl/bl.js\n");

/***/ })

};
;